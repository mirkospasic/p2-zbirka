
\chapter{Liste}

\section{Zadaci}
  % mozda iscepkati ove zadatke na pod zadatke <a svako popunjavanje
  %   i za pretraživanje

\begin{Exercise}[label=601]
Napisati program koji koristi jednostruko povezanu listu za čuvanje elemenata koji se unose sa standardnog ulaza. Unošenje novih brojeva u listu prekida se učitavanjem kraja ulaza (EOF). Svako dodavanje novog broja u listu ispratiti ispisivanjem trenutnog sadržaja liste. 
\begin{enumerate}
\item Definisati strukturu \kckod{Cvor} koja predstavlja čvor liste.
\item \komentar{Milena:Da li ovde treba dodati i funkciju koja kreira cvor? Nemam resenje kod sebe pa ne znam kako to vec ide, ali mislim da bi trebalo}

 \item Napisati funkciju koja dodaje novi elemenat na početak liste.
 \item Napisati funkciju koja dodaje novi elemenat na kraj liste.
 \item \komentar{Milena: Da li bi ovo trebalo izdvojiti u poseban zadatak? Nekako, ako dodajemo na pocetak i kraj, nemamo garanciju sortiranosti liste, tako da mi to nekako deluje da smo dva zadatka strpali u jedan.} Napisati funkciju koja dodaje novi elemenat u listu tako da lista ostane rastuće sortirana.
 \item Napisati funkciju koja oslobađa memoriju koju je zauzela lista.
 \item \komentar{Milena: Ova funkcija bi mogla razlicito da se implementira sa pretpostavkom da je lista sortirana i da nije sortirana, i zato mi dodatno deluje da bi ta dva zadatka trebalo razdvojiti} Napisati funkciju koja pretražuje listu za elementom koji ima vrednost koja je argument funkcije.
 \item Napisati funkciju koja briše sve elemente u listi koji imaju vrednost koja je argument funkcije.
 \item \komentar{Milena: Da li ovde nedostaje funckija koja oslobadja celu memoriju?}
 \end{enumerate}
%Sve funkcije za rad sa listom treba da budu iterativne.
Sve funckije za rad sa listom najpre implementirati iterativno, a zatim i rekurzivno.
\end{Exercise}
\begin{Answer}[ref=601]
\includecode{resenja/06_Liste/601.c}
\end{Answer}

\iffalse
\begin{Exercise}[label=602]
Prethodni zadatak uraditi tako da sve funkcije za rad sa listom budu rekurzivne.
\end{Exercise}
\begin{Answer}[ref=602]
\includecode{resenja/06_Liste/601.c}
\end{Answer}
\fi

\begin{Exercise}[label=603]
Napisati program koji koristi dvostruko povezanu listu za čuvanje
celih brojeva koji se unose sa standardnog ulaza. 
Unošenje novih brojeva u listu se prekida učitavanjem kraja ulaza (EOF). 
Svako dodavanje novog broja u listu ispratiti ispisivanjem trenutnog sadržaja liste. 
\komentar{I ovde isto mozda razdvojiti sortiranost od obične liste.}
\begin{enumerate}
 \item Napisati funkciju koja dodaje novi elemenat na početak liste.
 \item Napisati funkciju koja dodaje novi elemenat na kraj liste.
 \item Napisati funkciju koja dodaje novi elemenat u listu tako da lista ostane rastuće sortirana.
 \item Napisati funkciju koja oslobađa memoriju koju je zauzela lista.
 \item Napisati funkciju koja pretražuje listu za elementom koji ima vrednost koja je argument funkcije.
 \item Napisati funkciju koja briše sve elemente u listi koji imaju vrednost koja je argument funkcije.
\end{enumerate}
Sve funckije za rad sa listom implementirati iterativno.
\end{Exercise}
\begin{Answer}[ref=603]
\includecode{resenja/06_Liste/601.c}
\end{Answer}


\begin{Exercise}[label=608]
Sadržaj datoteke je aritmetički izraz koji može sadržati zagrade \{, [ i (. 
Napisati program koji učitava sadržaj datoteke i korišćenjem steka 
utvrđuje da li su zagrade u aritmetičkom izrazu 
dobro uparene. Program štampa odgovarajuću poruku na standardni izlaz.
\komentar{Milena: promenjeni test primeri, voditi racuna u resenjima sta se stampa!}

\begin{maxitest}
  \begin{test}{Test 1}
Datoteka: {[23 + 5344] * (24 - 234)} - 23
Izlaz:  Zagrade su ispravno uparene.
  \end{test}
\end{maxitest}

\begin{maxitest}
  \begin{test}{Test 2}
Datoteka: {[23 + 5] * (9 * 2)} - {23}
Izlaz:  Zagrade su ispravno uparene.
  \end{test}
\end{maxitest}

\begin{maxitest}
  \begin{test}{Test 3}
Datoteka: {[2 + 54) / (24 * 87)} + (234 + 23)
Izlaz:  Zagrade nisu ispravno uparene.
  \end{test}
\end{maxitest}

\end{Exercise}
\begin{Answer}[ref=608]
\includecode{resenja/06_Liste/601.c}
\end{Answer}


\begin{Exercise}[label=604]
Napisati program koji proverava ispravnost uparivanja etiketa u HTML datoteci. Ime datoteke se zadaje kao argument komandne linije . \komentar{Milena: A sta ako se ne navede argument komandne linije?}
Uputstvo: za rešavanje problema koristiti stek implementiran preko listi čiji su čvorovi HTML etikete.

\begin{maxitest}
    \begin{test}{Test 1}
Poziv: ./a.out datoteka.html
Datoteka.html:                          Izlaz:
<html>                                  Ispravno uparene etikete.
  <head><title>Primer</title></head>               
  <body>                                           
    <h1>Naslov</h1>                                
    Danas je lep i suncan dan. <br>                
    A sutra ce biti jos lepsi.     
    <a link="http://www.google.com"> Link 1</a>    
    <a link="http://www.math.rs"> Link 2</a>
  </body>
</html>
    \end{test}
\end{maxitest}

\begin{maxitest}    
  \begin{test}{Test 2}
Poziv: ./a.out datoteka.html
Datoteka.html:                          Izlaz:
<html>                                  Neispravno uparene etikete.
  <head><title>Primer</title></head>               
  <body>  
</html>
  \end{test}
\end{maxitest}

\begin{maxitest}      
  \begin{test}{Test 3}
Poziv: ./a.out datoteka.html
Datoteka.html:                          Izlaz:
<html>                                  Neispravno uparene etikete.
  <head><title>Primer</title></head>               
  <body>  
  </body>
  \end{test}
\end{maxitest}

\end{Exercise}
\begin{Answer}[ref=604]
\includecode{resenja/06_Liste/601.c}
\end{Answer}



\begin{Exercise}[label=605]
\komentar{Milena: Problem sa ovim zadatkom je sto je program najpre na usluzi korisnicima, a zatim na usluzi sluzbeniku i to nekako zbunjuje u formulaicji. Formulacija mi nije bila jasna bez citanja resenja, pokusala sam da je preciziran, u nastavku je izmenjena formulacija. \\Medjutim, ja i dalje nisam bas zadovoljna i zato predlazem da se formulacija izmeni tako da je program stalno na usluzi sluzbeniku. Program ucitva podatke o prijavljenim korisnicima iz datoteke. Sluzbenik odlucuje da li ce da obradjuje redom korisnike, ili ce u nekim situacijama da odlozi rad sa korisnikom i stavi ga na kraj reda. Program ga uvek pita da na osnovu jmbg-a i zahteva odluci da li ce ga staviti na kraj reda, ako hoce, on ide na kraj reda, ako nece, onda  sluzbenik daje odgovor na zahtev i jmbg, zahtev i odgovor se upisuju u izlaznu datoteku.}

Napisati program kojim se simulira rad jednog šaltera na kojem se prvo zakazuju 
termini, a potom službenik uslužuje korisnike redom, kako su se prijavljivali.

Korisnik se prijavljuje unošenjem svog \kckod{jmbg} broja (niska koja sadrži $13$ karaktera) i zahteva (niska koja sadrži najviše $999$ karaktera). Prijavljivanje korisnika se prekida unošenjem karaktera za kraj ulaza (\kckod{EOF}).

Službenik redom proziva korisnike čitanjem njihovog \kckod{jmbg} broja, a zatim odlučuje da li 
korisnika vraća na kraj reda ili ga odmah uslužuje. Službeniku se postavlja pitanje 
\kckod{Da li korisnika  vracate na kraj reda?} i ukoliko on da odgovor \kckod{Da}, 
korisnik se vraća na kraj reda. Ukoliko odgovor nije \kckod{Da}, tada službenik čita korisnikov zahtev.  
Posle svakog $10$ usluženog korisnika, službeniku se nudi 
mogućnost da prekine sa radom, nevezano od broja korisnika koji i dalje čekaju u redu. 

Za čuvanje korisničkih zahteva koristiti red implementiran korišćenjem listi.
\end{Exercise}
\begin{Answer}[ref=605]
\includecode{resenja/06_Liste/601.c}
\end{Answer}


%%% Obavezni sa praktikuma

\begin{Exercise}[label=606]
\komentar{Milena: Dodati sta se desava ako nije zadat argument komandne linije ili ako datoteka ne postoji}
Napisati program koji prebrojava pojavljivanja etiketa HTML 
datoteke čije se ime zadaje kao argument komandne linije. Rezultat prebrojavanja 
ispisati na standardni izlaz. Etikete smeštati u listu, a za formiranje liste koristiti strukturu:
\begin{ckod} 
 typedef struct _Element
 {
   unsigned broj_pojavljivanja;
   char etiketa[20];
   struct _Element *sledeci;
 } Element;
\end{ckod}

\begin{maxitest}
    \begin{test}{Test 1}
Poziv: ./a.out datoteka.html
Datoteka.html:                                     Izlaz:
<html>                                             a - 4
  <head><title>Primer</title></head>               br - 1
  <body>                                           h1 - 2
    <h1>Naslov</h1>                                body - 2
    Danas je lep i suncan dan. <br>                title - 2
    A sutra ce biti jos lepsi.                     head - 2
    <a link="http://www.google.com"> Link 1</a>    html - 2
    <a link="http://www.math.rs"> Link 2</a>
  </body>
</html>
    \end{test}
\end{maxitest}

\end{Exercise}
\begin{Answer}[ref=606]
\includecode{resenja/06_Liste/601.c}
\end{Answer}



\begin{Exercise}[label=607]
\komentar{Milena: i ovde dodati sta ako nema argumenata i ako nema datoteka, kao i u svim ostalim zadacima, a ne bih stalno ovaj komentar ponavljala. Takodje, malo me muci u ovom zadatku sto nema neki smisao. Naime, ako se samo vrsi ucitavanje iz datoteka i ispisivanje, onda su ove liste zapravo visak jer isti rezultat moze da se dobije i bez koriscenja listi. Zato mi fali da program uradi nesto sto ne bi mogao da uradi bez koriscenja listi, npr da na osnovu unetog broja ispisuje svaki n-ti broj rezultujuce liste pa to u nekoj petlji  da korisnik moze da ispisuje za razlicite unete n ili tako nesto... }

Napisati program koji objedinjuje dve sortirane liste. Funkcija ne treba da 
kreira nove čvorove, već da samo
postojeće čvorove preraspodeli. Prva lista se učitava iz datoteke koja se 
zadaje kao prvi argument komandne
linije, a druga iz datoteke čije se ime zadaje kao drugi argument komandne linije. Rezultujuću listu ispisati na standardni izlaz.

\begin{miditest}
  \begin{test}{Test 1}
Poziv: ./a.out dat1.txt dat2.txt
dat1.txt: 2 4 6 10 15
dat2.txt: 5 6 11 12 14 16
Izlaz: 2 4 5 6 6 10 11 12 14 15 16
  \end{test}
\end{miditest}
  
\end{Exercise}
\begin{Answer}[ref=607]
\includecode{resenja/06_Liste/601.c}
\end{Answer}



\begin{Exercise}[label=608]
Napisati funkciju koja formira listu studenata tako što se podaci o studentima 
učitavaju iz datoteke čije se ime zadaje kao argument komandne linije. 
U svakom redu datoteke nalaze se podaci o studentu i to broj indeksa, ime
i prezime. Napisati rekurzivnu funkciju koja određuje da li neki student pripada listi ili ne.
Ispisati zatim odgovarajuću poruku i rekurzivno osloboditi memoriju koju je data lista zauzimala.
Student se traži na osnovu broja indeksa, koji se zadaje sa standardnog ulaza.
\begin{maxitest}
    \begin{test}{Test 1}
Poziv: ./a.out studenti.txt
Datoteka:                 Ulaz:       Izlaz:
123/2014 Marko Lukic      3/2014      da: Ana Sokic
3/2014 Ana Sokic          235/2008    ne
43/2013 Jelena Ilic       41/2009     da: Marija Zaric
41/2009 Marija Zaric
13/2010 Milovan Lazic
  \end{test}
\end{maxitest}

\end{Exercise}
\begin{Answer}[ref=608]
\includecode{resenja/06_Liste/601.c}
\end{Answer}

\komentar{Milena: Imamo dva zadatka sa labelom 608!}


%% Dodatni


\begin{Exercise}[label=609]
Neka su date dve jednostruko povezane liste L1 i L2. Napisati funkciju koja od 
tih lista formira novu listu L koja sadrži alternirajući raspoređene elemente 
lista L1 i L2 (prvi element iz L1, prvi element iz L2, drugi element L1,
drugi element L2, itd). Ne formirati nove čvorove, već samo postojeće čvorove 
rasporediti u jednu listu. Prva lista se učitava iz datoteke koja se zadaje 
kao prvi argument komandne linije, a druga iz datoteke čije se ime zadaje kao 
drugi argument komandne linije. Rezultujuću listu ispisati 
na standardni izlaz. \komentar{Milena: Sta ako je neka lita duza? To precizirati. I ovde me muci
sto nedostaje neki smisao zadatku, nesto sto ne bi moglo da se uradi da nismo kristili liste. }

\begin{miditest}
  \begin{test}{Test 1}
Poziv: ./a.out dat1.txt dat2.txt
dat1.txt: 2 4 6 10 15
dat2.txt: 5 6 11 12 14 16
Izlaz:  2 5 4 6 6 11 10 12 15 14 16
  \end{test}
\end{miditest}

\end{Exercise}
\begin{Answer}[ref=609]
\includecode{resenja/06_Liste/601.c}
\end{Answer}



\begin{Exercise}[label=610]
Data je datotka brojevi.txt koja sadrži cele brojeve, po jedan u svakom redu.
\begin{enumerate}
 \item Napisati funkciju koja iz zadate datoteke učitava brojeve i smešta ih u listu.
 \item Napisati funkciju koja u jednom prolazu kroz zadatu listu celih brojeva 
pronalazi maximalan strogo rastući podniz.
\end{enumerate}
Napisati program koji u datoteku \kckod{Rezultat.txt} upisuje nađeni strogo rastući podniz.
\komentar{Milena: I ovde me muci sto bi zadatak mogao da se resi i bez koriscenja listi... }

\komentar{Milena: Prirodni oblik testa ovde bi bio horizontalan, a ne ovako vertikalan.}
\begin{maxitest}
  \begin{test}{Test 1}
Ulaz:  brojevi.txt       Izlaz: Rezultat.txt
       43                            12
       12                            15
       15                            16
       16
       4
       2
       8
  \end{test}
\end{maxitest}

\end{Exercise}
\begin{Answer}[ref=610]
\includecode{resenja/06_Liste/601.c}
\end{Answer}



\begin{Exercise}[label=611]
Grupa od n plesača na kostimima imaju brojeve od 1 do n, redom, u smeru kazaljke na satu.
Plesači izvode svoju plesnu tačku tako što formiraju krug iz kog najpre izlazi k-ti plesač.
Odbrojava se počevši od plesača označenog brojem 1 u smeru kretanja kazaljke na satu. 
Preostali plesači obrazuju manji krug iz kog opet izlazi k-ti plesač. Odbrojavanje počinje od
sledećeg suseda prethodno izbačenog, opet u smeru kazaljke na satu. Izlasci iz kruga se nastavljaju
sve dok svi plesači ne budu isključeni. 
Celi brojevi n, k (k < n) se učitavaju sa standardnog ulaza. Napisati program koji će na standardni 
izlaz ispisati redne brojeve plesača u redosledu napuštanja kruga. 
Uputstvo: u implementaciji koristiti kružnu listu.
\begin{maxitest}
  \begin{test}{Test 1}
Ulaz: 5 3 
Izlaz: 3 1 5 2 4
  \end{test}
\end{maxitest}

\end{Exercise}
\begin{Answer}[ref=611]
\includecode{resenja/06_Liste/601.c}
\end{Answer}

\komentar{Milena: Bilo bi lepo dodati i prethodni zadatak u kojem se smer izbacivanja stalno menja, tako da se onda korsti dvostruko povezana kružna lista.}

\section{Rešenja}
\shipoutAnswer


